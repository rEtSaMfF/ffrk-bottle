#!/usr/bin/env python3

import json
import datetime
import os

from bottle import Bottle, redirect, request, response, TEMPLATE_PATH, error,\
    abort, static_file, BaseRequest, jinja2_view as view, Jinja2Template
from bottle.ext import sqlalchemy

from time import time
from wsgi import models

### BOTTLE INIT START ###
app = application = Bottle()
app.debug = True
BaseRequest.MEMFILE_MAX = 1024 * 1024 * 2

TEMPLATE_PATH.insert(0, './wsgi/views/')

@app.error(500)
@app.error(403)
@app.error(404)
@view('404.html')
def error404(e):
    return {'error':e.body}

Jinja2Template.defaults['url'] = app.get_url
### BOTTLE INIT END ###


def dump_json(data, filepath='/tmp/ffrk.json'):
    # TODO 2015-05-11
    # --verbose or logging this
    print ('Writing {}'.format(filepath))
    with open(filepath, 'w') as outfile:
        #json.dump(data, outfile, sort_keys=True, indent=2, ensure_ascii=True)
        json.dump(data, outfile, sort_keys=True, ensure_ascii=True)


@app.get('/static/<filepath:path>', name='static')
def statics(filepath):
    print ('backend static request for {}'.format(filepath))
    root = os.path.join('.', 'wsgi', 'static')
    for ext in ('js', 'css'):
        if filepath.endswith('.{}'.format(ext)):
            root = os.path.join(root, ext)
        if filepath.startswith('{}/'.format(ext)):
            filepath = filepath[len('{}/'.format(ext)):]
    return static_file(filepath, root=root)


@app.route('/<iden>', name='main')
@view('main.html')
def main(iden=None):
    '''
    Render a page for a single object.
    Corresponds with url('json_id').
    '''
    try:
        iden = int(iden)
    except ValueError:
        o = models.get_by_name(iden)
    else:
        o = models.get_by_id(iden)

    if o is not None:
        context = {
            'o': o,
        }
        try:
            return context
        except TemplateSyntaxError as e:
            print ('{}:{}'.format(e.filename, e.lineno))
    abort(404, 'Object "{}" not found'.format(iden))


@app.route('/', name='home')
@view('table.html')
def home():
    '''
    Render a table.
    orresponds with url('json').
    '''
    # TODO 2015-05-06
    # Make a real home page
    # 2015-05-07
    # We have an about page at least
    category = request.GET.get('category', '').lower()
    if not category:
        redirect(app.get_url('main', iden='about'))
    rarity = request.GET.get('rarity', 'all')
    columns = ()
    for c, cs in (
        (('material', 'materials'), models.Material.frontend_columns),
        (('enemy', 'enemies'), models.Enemy.frontend_columns),
        (('relic', 'relics'), models.Relic.frontend_columns),
        (('ability', 'abilities'), models.Ability.frontend_columns),
        (('world', 'worlds', 'realm', 'realms'), models.World.frontend_columns),
        (('log', 'logs'), models.Log.frontend_columns),
    ):
        if category in c:
            columns = cs
            break
    context = {'rarity': rarity, 'category': category, 'columns': columns}

    try:
        return context
    except TemplateSyntaxError as e:
        print ('{}:{}'.format(e.filename, e.lineno))
        abort(500, str(e))
    # Do we need an abort here?


@app.route('/dungeon', name='dungeon')
@app.route('/dungeons', name='dungeons')
@view('dungeons.html')
def dungeons():
    '''
    Render a dungeon table listing.
    Corresponds with url('json_dungeons').
    '''
    content = request.GET.get('content')
    columns = (
        ('challenge_level', 'Difficulty'),
        ('world_name', 'Realm'),
        ('name', 'Name'),
        ('type', 'Type'),
        ('conditions', 'Conditions'),
        ('stamina', 'Stamina'),
        ('shards',
         'Shards <span title="First Time Reward + Mastery Reward" class="glyphicon glyphicon-info-sign" aria-hidden="true"></span>'),
        ('prizes', 'Rewards'),
    )

    context = {'columns': columns, 'content': content}
    try:
        return context
    except TemplateSyntaxError as e:
        print ('{}:{}'.format(e.filename, e.lineno))
        abort(500, str(e))
    # Do we need an abort here?


@app.route('/dungeons.json', name='json_dungeons')
@app.route('/json/dungeons')
def json_dungeons():
    '''
    Get JSON for dungeon listings.
    '''
    # TODO 2015-05-18
    # Filter dungeons by release.
    # TODO 2015-05-18
    # Add menu item to filter dungeons by release.
    response.content_type = 'application/json; charset=UTF8'

    content = request.GET.get('content')
    dungeons = models.get_dungeons(content)

    if dungeons:
        outlist = []
        for dungeon in dungeons:
            row = dungeon.dict()
            row['world_name'] = dungeon.world.name
            row['type'] = models.DUNGEON_TYPE[dungeon.dungeon_type]
            row['conditions'] = 'To be implemented (hopefully).'
            shards = 0
            prizes = []
            for prize in dungeon.prizes:
                if prize.name == 'Stamina Shard':
                    shards += prize.count
                    continue
                if prize.drop_type != 'COMMON':
                    prizes.append('<a href="{}">{}</a>'.format(
                        app.get_url('main', iden=prize.search_id), prize))
                else:
                    prizes.append(str(prize))
            row['shards'] = shards
            row['prizes'] = '<br>'.join(prizes)
            stamina = 0
            conditions = ['*To be implemented (hopefully).']
            for battle in dungeon.battles:
                stamina += battle.stamina
                #for c in battle.conditions:
                #    conditions.append(c)
            row['stamina'] = stamina
            row['conditions'] = '<br>'.join(conditions)
            outlist.append(row)
        return json.dumps(outlist,
                          default=models.default_encode, separators=(',',':'))

    response.status = 404
    return json.dumps(
        {'success':False, 'error':'No results found'}, separators=(',',':'))


@app.route('/json/<id:int>', name='json_id')
def get_json_by_id(id):
    '''
    Get JSON for an object (or all similar objects).
    '''
    response.content_type = 'application/json; charset=UTF8'

    all = request.GET.get('all', False)
    enemy = request.GET.get('enemy', False)
    r = models.get_by_id(id, all=all, enemy=enemy)

    if r:
        if hasattr(r, 'jsonify'):
            # This is a single object
            return r.jsonify()
        # We have a list of objects
        return json.dumps([i.dict() for i in r],
                          default=models.default_encode, separators=(',',':'))

    response.status = 404
    return json.dumps(
        {'success':False, 'error':'No results found'}, separators=(',',':'))


@app.route('/json', name='json')
def get_json():
    '''
    Get JSON for a category (table).
    '''
    response.content_type = 'application/json; charset=UTF8'

    category = request.GET.get('category', None)
    if category is None:
        response.status = 404
        return json.dumps(
            {'success':False, 'error':'Unknown category'}, separators=(',',':'))
    category = category.lower()

    rarity = request.GET.get('rarity', 'all').lower()
    with models.session_scope() as session:
        q = None
        # category, model, order_by, group_by, rarity, limit, filter
        for c, m, o, g, r, l, f in (
            (('material', 'materials'),
             models.Material, 'name', 'id', False, None, None),
            (('ability', 'abilities'),
             models.Ability, 'name', 'name', False, None, None),
            (('enemy', 'enemies'),
             #models.Enemy, 'name DESC', 'name', True, None, None),
             models.Enemy, 'name DESC', 'enemy_id', True, None, None),
             #models.Enemy, 'name DESC', 'param_id', True, None, None),
             # TODO 2015-05-18
             # Filter out blank names (or group such that the non-blanks win)
            (('relic', 'relics'),
             models.Relic, 'name', 'name', False, None, None),
            (('world', 'worlds'), models.World, 'id', 'id', True, None, None),
            (('dungeon', 'dungeons'),
             models.Dungeon, 'id', 'id', True, None, models.Dungeon.world_id),
            # TODO 2015-05-07
            # Enhance server-side pagination for Log
            # request.GET.get('offset', 0)
            # request.GET.get('limit', 25)
            (('log', 'logs'),
             models.Log, models.Log.timestamp.desc(), 'id', True, 100, None),
        ):
            if category in c:
                q = session.query(m).order_by(o).group_by(g).limit(l)
                #q = session.query(models.Relic).filter(models.Relic.series_id.notlike(1)).group_by('name').order_by('name')
                if r:
                    rarity = 'all'
                break
        if q is None:
            response.status = 404
            return json.dumps(
                {'success':False, 'error':'Unknown category'}, separators=(',',':'))
        if rarity != 'all':
            # Some tables do not have a rarity column
            q = q.filter_by(rarity=rarity)
        filter = request.GET.get('filter')
        if filter is not None:
            q = q.filter(f == filter)
        q = q.all()
        if q:
            return json.dumps(
                [i.dict() for i in q],
                default=models.default_encode, separators=(',',':'))
        response.status = 404
        return json.dumps(
            {'success':False, 'error':'No results found'}, separators=(',',':'))


@app.route('/post', method='POST')
def post():
    '''
    Parse a new FFRK response (intercepted from a client).

    This is basically the same thing as ffrk_mitm.response() except that
    here we pick the proper function from the 'action' key instead of
    flow.request.path.
    '''
    #abort(403, '403 Forbidden')
    response.content_type = 'application/json; charset=UTF8'
    try:
        data = request.json
        action = data['action']
        filepath = '/tmp/ffrk-{}-{}.json'.format(
            action.replace('/', '_'), int(time()*1000000))
        #dump_json(data, filepath=filepath)
        del(data['action'])
        for a, m in (
                ('get_battle_init_data', models.import_battle),
                ('/dff/world/battles', models.import_battle_list),
                ('/dff/world/dungeons', models.import_world),
        ):
            if action == a:
                if m(data=data, filepath=filepath):
                    return json.dumps({'success': True}, separators=(',',':'))
                else:
                    response.status = 500
                    return json.dumps(
                        {'success':False, 'error':'Bad data'},
                        separators=(',',':'))
        response.status = 500
        return json.dumps(
            {'success':False, 'error':'Unknown action'}, separators=(',',':'))
    except Exception as e:
        print (e)
        response.status = 500
        return json.dumps(
            {
                'success':False,
                'error':'{}: {}'.format(str(e.__class__), str(e))
            },
            separators=(',',':')
        )


### EOF ###
